Mono管理器的作用：
使没有继承MonoBehavior的类能够开启协程，并且可以使用FixedUpdate，Update，LateUpdate进行每帧更新。

原理：
1.在场景中创建一个继承MonoBehavior的“执行者”脚本，这个脚本就专门用来开启协程和监听帧更新
	1.开启协程可以直接StartCoroutine，2.监听帧更新用的是委托事件在update中执行，还需要提供一个可以在MonoManager添加事件的方法，移除同理
	2.执行者中的函数无论是MonoBehavior自带的StartCoroutine，还是我们后续添加的监听事件的方法，这些都不能被外部调用只能被MonoManager这个老大来使用
2.Mono管理器访问这个“执行者”脚本，就可以实现所需效果。
	1.因为MonoManager作为管理器就是一个单例模式，因此就要为外部（没有继承MonoBehavior的类）提供开启协程，监听帧更新等方法
		注意：凡是需要添加事件的都不要用lambda表达式，因为移除事就没办法移除指定事件
这里Mono管理器就相当于是一个老大，执行者就相当于是一个小弟，老大想要执行协程和帧更新等就直接吩咐小弟执行，不用自己亲自执行


MonoCtroller为“执行者”--Framework
MonoManager为Mono管理器，用来操作执行者开启协程等--Framework
Player为用来测试用的没有继承自MonoBehaviour的一个普通脚本

注意：
1.这里还可以对Mono管理器进行优化，那就是把执行者这个类嵌套进Mono管理器类，这样有个好处就是可以在vs编译器中隐藏掉创建执行者的这个提示
这样就会变成一个Mono管理器。不过也可以不把执行嵌套进Mono管理器，使得功能明确一点
2.这个框架还有一点比较局限，那就是因此执行者脚本使用的UnityAction事件(0参数的委托)，因此只能对没有参数的方法进行帧更新或者开启协程等，还可以用委托增加参数的个数并且转换为事件
这样就可以实现多个参数的函数可以进行帧更新等