单例模式说简单点就是一个类只允许创建一个对象实例，单例类必须自己创建自身的唯一实例单例类必须给其余系统对象提供创建的唯一实例。单例模式的用处很广泛
比如玩家数据，整个游戏就只需要一个玩家数据，因此就只需要一个玩家数据的实例对象，无论是获取还是更改玩家数据，这样才能让数据在各处进行同步。

创建的步骤:
1.构造函数私有化，防止外部创建对象
2.提供一个静态属性（或者方法）返回私有静态对象实例给外部访问

单例模式有两种方式：
1.懒汉单例模式
2.饿汗单例模式
这两者的区别就在于
懒汉：不会提前创建对象实例，只会在使用时才会创建实例(只会创建一次实例)
饿汉：在单例对象声明时就创建了对象实例,该对象就会在程序一开始就占据着一定的内存

在unity中有继承自MonoBehavior和不继承MonoBehavior的单例，虽然写法不太一样，但是大致单例模式的思路是一样的
如果用饿汉单例模式的话，继承自MonoBehavior的用this给实例对象赋值，没继承的用new即可
如果用懒汉单例模式的话，继承自MonoBehavior的需要从场景中查找到该脚本（这里就涉及一个自动单例模式和切换场景的问题），随后给实例对象赋值(这里是用属性时才这样)，没继承的用new即可
	自动单例模式：因为需要从场景中查找到该脚本给实例对象赋，那如果场景中不存在该游戏对象，就需要在代码中创建游戏对象，并添加脚本，实现自动单例模式；没继承自MonoBehavior的用的new就不存在该问题
	切换场景：因为单例模式就一个实例对象，切换场景后悔自动销毁当前场景的所有对象，如果再新场景中重新创新实例对象就会出问题，因此要为挂载了该脚本的游戏对象添加DontDestroyOnLoad（）方法

在使用到很多个不同的单例模式的情况下，如果反复书写单例模式就比较麻烦，因此就会有单例模式的基类，供需要写单例模式的脚本继承
1.不继承MonoBehaviour的单例模式的基类
	这里需要注意基类和子类的构造函数私有化，因此基类的泛型约束不能用new()，并且基类的构造函数应该为protected，这样子类才能继承
	但是为了方便的话，也可以在基类的泛型约束加上new()，不对子类构造函数私有化也可以，只不过需要在开发时注意不要创建多个子类对象既可
2.继承MonoBehaviour的单例模式的基类
	自动单例模式和切换场景同之前一样，这里因为创建对用不到new了，因此就不用添加new()的泛型约束，这样就不用考虑上方添加new()泛型约束和子类构造函数私有化的矛盾
	

注意事项：
1.在OnDestroy的生命周期函数中是不允许创建游戏对象的，如果在该生命周期函数中使用了单例模式（其中有自动单例模式），就会报错，OnDestroy中方法单例时就需要做个条件判断，判断单例是否存在，其中SingletonPatternMonoBase类中有是否存在该单例的属性
2.多线程访问单例（只会出现在没继承MonoBehaviour的类中，因为MonoBehaviour只允许单线程），当多线程访问单例模式时，可能会创建多个实例，因此就可以加上双锁来保证对象唯一性，SingletonPatternBase已经添加上了双锁

参考代码：
PlayerModel为继承成MonoBehavior的单例模式
MyUIManager为继承MonoBehavior的单例模式

SingletonPatternBase为不继承MonoBehaviour的单例模式的基类--Framwork
SingletonPatternChild为不继承MonoBehaviour的单例模式的子类

SingletonPatternMonoBase为继承了MonoBehavior的单例模式基类--Framwork(自动单例模式和切换场景不销毁在该脚本中同时实现，可以根据项目需求调整)
SingletonPatternMonoChild为继承了MonoBehavior的单例模式的子类
